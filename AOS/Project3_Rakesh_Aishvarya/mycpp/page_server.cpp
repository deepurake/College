// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "page.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <curl/curl.h>
#include <fstream>
#include <sstream>
#include <iostream>
#include <sys/timeb.h>

#include "HashMapList.hpp"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using namespace std;
using namespace  ::page;
HashMapList* DS;

TSimpleServer *my_server;
class pageHandler : virtual public pageIf {

public:
  int service_count;
  int cache_misses;
  long access_time;
  pageHandler() {
    // Your initialization goes here
    service_count = 0;
    cache_misses = 0;
    access_time = 0;
  }

  static size_t data_write(void* buf, size_t size, size_t nmemb, void* userp)
  {
  	if(userp)
  	{
  		std::ostream& os = *static_cast<std::ostream*>(userp);
  		std::streamsize len = size * nmemb;
  		if(os.write(static_cast<char*>(buf), len))
  			return len;
  	}

  	return 0;
  }

  void http_get_body(std::string& _return, const std::string& pageurl)
  {
    // Fetch the URL
    CURL *curl;
    CURLcode code;
    ostringstream oss;
    curl = curl_easy_init();
    if(curl) 
    {
     string str (pageurl);

      /* Perform the request, res will get the return code */ 
  
      if(CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &data_write))
        && CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L))
        && CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L))
        && CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_WRITEDATA, &oss))
        && CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_URL, str.c_str())))
      {
        code = curl_easy_perform(curl);
      }
      /* Check for errors */ 
      if(code != CURLE_OK)
        fprintf(stderr, "curl_easy_perform() failed: %s\n",
                curl_easy_strerror(code));

      /* always cleanup */ 
      curl_easy_cleanup(curl);
    }
    _return = oss.str();
    char *x = (char *)malloc((_return.length())+1);
    memcpy(x, _return.c_str(), _return.length());
    DS->insert(x,string(pageurl));

    // update the cache DS
    // TBD
  }
  bool fetch_from_cache(string& _return, string pageurl)
  {
    //TBD
    bool ret = DS->fetch(_return,pageurl);
    return ret;
  }
  void print_stats()
  {
    cout << "Total queries:\t" << service_count << endl; 
    cout << "Cache Misses:\t" << cache_misses << endl;
    cout << "Miss Ratio:\t" << ((float)cache_misses)/(float)service_count << endl;
    cout << "Access Time:\t" << access_time << endl;
    cout << "Average Access Time:\t" << access_time/service_count << endl;
    cout << "=======================================================" << endl;
  }
  int getMilliCount(){
    timeb tb;
    ftime(&tb);
    int nCount = tb.millitm + (tb.time & 0xfffff) * 1000;
    return nCount;
  }

  int getMilliSpan(int nTimeStart){
    int nSpan = getMilliCount() - nTimeStart;
    if(nSpan < 0)
      nSpan += 0x100000 * 1000;
    return nSpan;
  }
  void getPageBody(std::string& _return, const std::string& pageurl) 
  {
    
    int start = getMilliCount();

    if(string(pageurl).compare("terminate") == 0)
    {
      print_stats();
      _return = "thank you";
      my_server->stop();
      return;
    }
#ifdef debug
    cout << "fetching "<< pageurl << endl;
#endif
    service_count++;
    // Step 1
    // Check the cache and fetch and return.
    if(fetch_from_cache(_return,string(pageurl)))
    {
      // Update cache data structs as per requirements.
#ifdef debug
      cout << "cache hit"<< endl;
      cout << "service count" << service_count << endl;
#endif
    }
    else
    {
      // Step 2
      // If it is not in the cache call the curl part and update cache as per req.
#ifdef debug
      cout<<"cache miss"<<endl;
#endif
      cache_misses ++;
      http_get_body(_return,pageurl);

#ifdef debug
      cout << "service count" << service_count <<endl;
#endif
    }

    int milliSecondsElapsed = getMilliSpan(start);
#ifdef debug
    printf("Finnished in %d milliseconds. \n", milliSecondsElapsed);
#endif
    access_time += milliSecondsElapsed;
  }

};


int main(int argc, char **argv) {
  scheme cache_scheme = LRU;
  int max_size = 1024*1024;
  if(argc > 2)
  {
    cache_scheme = (scheme)atoi(argv[1]);
    max_size = atoi(argv[2])*1024;
    cout << "cache scheme:\t" << cache_scheme << endl;
    cout << "cache size:\t" << max_size << endl;
  }
  DS = new HashMapList(cache_scheme,max_size);
  string a = "yes";
  string b = "to";
  HashMapList x();
  //DS = 
  int port = 9090;
  shared_ptr<pageHandler> handler(new pageHandler());
  shared_ptr<TProcessor> processor(new pageProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  my_server = new TSimpleServer(processor, serverTransport, transportFactory, protocolFactory);
  my_server->serve();
  return 0;
}